#!/usr/bin/env python3
"""
Monthly Dishes Report worksheet generator (ËèúÂìÅÁî®ÊñôÊúàÊä•).
Displays comprehensive dish-material relationship data from the database.
"""

from datetime import datetime
from openpyxl.styles import PatternFill, Font, Alignment, Border, Side
from openpyxl.utils import get_column_letter
from typing import List, Dict


class MonthlyDishesWorksheetGenerator:
    """Generate monthly dishes report worksheet (ËèúÂìÅÁî®ÊñôÊúàÊä•) from database data"""

    def __init__(self, store_names, target_date):
        self.store_names = store_names
        self.target_date = target_date

    def generate_worksheet(self, wb, data_provider):
        """Generate the monthly dishes worksheet from database data"""

        ws = wb.create_sheet("ËèúÂìÅÁî®ÊñôÊúàÊä•")

        # Parse target date for title
        target_dt = datetime.strptime(self.target_date, '%Y-%m-%d')

        # Get dish-material data from database
        dish_data = self.get_dish_material_data(data_provider)

        if not dish_data:
            # Create empty worksheet with message
            ws['A1'] = "Êó†ÂèØÁî®Êï∞ÊçÆ - No Data Available"
            ws['A1'].font = Font(bold=True, size=14)
            return ws

        # Set column widths for readability
        column_widths = [8, 12, 15, 12, 12, 15, 12, 25,
                         25, 12, 15, 12, 12, 15, 15, 15, 15, 15, 15, 10]
        for i, width in enumerate(column_widths, 1):
            if i <= len(column_widths):
                ws.column_dimensions[get_column_letter(i)].width = width

        current_row = 1

        # Title section
        ws.merge_cells(f'A{current_row}:T{current_row}')
        ws[f'A{current_row}'] = f"Êµ∑Â∫ïÊçûËèúÂìÅÁî®ÊñôÊúàÊä• - {target_dt.strftime('%YÂπ¥%mÊúà')}"
        ws[f'A{current_row}'].font = Font(bold=True, size=16, color="FFFFFF")
        ws[f'A{current_row}'].alignment = Alignment(
            horizontal='center', vertical='center')
        ws[f'A{current_row}'].fill = PatternFill(
            start_color="C41E3A", end_color="C41E3A", fill_type="solid")
        current_row += 2

        # Summary section
        current_row = self.add_summary_section(ws, current_row, dish_data)

        # Main data section
        current_row = self.add_dish_data_section(ws, current_row, dish_data)

        # Apply common formatting
        self.apply_common_formatting(ws, current_row - 1)

        return ws

    def generate_material_variance_worksheet(self, wb, data_provider):
        """Generate material variance analysis worksheets - one per store"""

        # Parse target date for title
        target_dt = datetime.strptime(self.target_date, '%Y-%m-%d')
        year, month = target_dt.year, target_dt.month

        # Get material variance data
        variance_data = self.get_material_variance_data(
            data_provider, year, month)

        if not variance_data:
            # Create empty worksheet with message
            ws = wb.create_sheet("Áâ©ÊñôÁî®ÈáèÂ∑ÆÂºÇÂàÜÊûê")
            ws['A1'] = "Êó†ÂèØÁî®Êï∞ÊçÆ - No Variance Data Available"
            ws['A1'].font = Font(bold=True, size=14)
            return ws

        # Group variance data by store
        stores_data = {}
        for data in variance_data:
            store_name = data['store_name']
            if store_name not in stores_data:
                stores_data[store_name] = []
            stores_data[store_name].append(data)

        # Create a worksheet for each store
        created_worksheets = []
        for store_name, store_variance_data in stores_data.items():
            ws = self.create_store_variance_worksheet(wb, store_name, store_variance_data, target_dt)
            created_worksheets.append(ws)

        return created_worksheets

    def create_store_variance_worksheet(self, wb, store_name, store_variance_data, target_dt):
        """Create a variance analysis worksheet for a specific store"""
        
        # Create sheet name with store identifier
        sheet_name = f"Áâ©ÊñôÁî®ÈáèÂ∑ÆÂºÇÂàÜÊûê-{store_name}"
        ws = wb.create_sheet(sheet_name)

        # Set column widths for readability (added dish usage details, minus inventory, and 2 cost columns)
        column_widths = [8, 12, 15, 12, 8, 25, 15, 15, 15, 15, 15, 12, 20, 12, 15, 15]
        for i, width in enumerate(column_widths, 1):
            if i <= len(column_widths):
                ws.column_dimensions[get_column_letter(i)].width = width

        current_row = 1

        # Title section (now extends to P column for 16 columns)
        ws.merge_cells(f'A{current_row}:P{current_row}')
        ws[f'A{current_row}'] = f"Áâ©ÊñôÁî®ÈáèÂ∑ÆÂºÇÂàÜÊûê - {store_name} - {target_dt.strftime('%YÂπ¥%mÊúà')}"
        ws[f'A{current_row}'].font = Font(bold=True, size=16, color="FFFFFF")
        ws[f'A{current_row}'].alignment = Alignment(
            horizontal='center', vertical='center')
        ws[f'A{current_row}'].fill = PatternFill(
            start_color="C41E3A", end_color="C41E3A", fill_type="solid")
        current_row += 2

        # Summary section for this store
        current_row = self.add_store_variance_summary_section(
            ws, current_row, store_variance_data, store_name)

        # Main variance data section for this store
        current_row = self.add_variance_data_section(
            ws, current_row, store_variance_data)

        # Apply variance formatting
        self.apply_variance_formatting(ws, current_row - 1)

        return ws

    def add_store_variance_summary_section(self, ws, start_row, variance_data, store_name):
        """Add variance summary statistics section for a specific store"""
        current_row = start_row

        # Calculate summary statistics for this store
        total_materials = len(variance_data)
        materials_over_threshold = len(
            [row for row in variance_data if abs(row['variance_percent']) > 5])
        materials_normal = total_materials - materials_over_threshold

        over_usage = len(
            [row for row in variance_data if row['variance_percent'] > 5])
        under_usage = len(
            [row for row in variance_data if row['variance_percent'] < -5])

        total_theoretical = sum(row['theoretical_usage']
                                for row in variance_data)
        total_combo_usage = sum(row['combo_usage']
                                for row in variance_data)
        total_combined_theoretical = total_theoretical + total_combo_usage
        total_system = sum(row['system_record'] for row in variance_data)
        total_inventory = sum(row['inventory_count'] for row in variance_data)
        total_variance = total_system - total_combined_theoretical
        overall_variance_percent = (
            total_variance / total_combined_theoretical * 100) if total_combined_theoretical > 0 else 0

        # Create summary section
        ws.merge_cells(f'A{current_row}:D{current_row}')
        ws[f'A{current_row}'] = f"{store_name} - Â∑ÆÂºÇÂàÜÊûêÊ¶ÇËßà"
        ws[f'A{current_row}'].font = Font(bold=True, size=12)
        ws[f'A{current_row}'].fill = PatternFill(
            start_color="E6F3FF", end_color="E6F3FF", fill_type="solid")
        current_row += 1

        summary_data = [
            ("Áâ©ÊñôÊÄªÊï∞", total_materials),
            ("Â∑ÆÂºÇË∂Ö5%Áâ©Êñô", materials_over_threshold),
            ("Ê≠£Â∏∏ËåÉÂõ¥Áâ©Êñô", materials_normal),
            ("Ë∂ÖÈáè‰ΩøÁî®Áâ©Êñô", over_usage),
            ("Â∞ëÁî®Áâ©Êñô", under_usage),
            ("ÊÄªÁêÜËÆ∫Áî®Èáè", f"{total_theoretical:.2f}"),
            ("ÊÄªÂ•óÈ§êÁî®Èáè", f"{total_combo_usage:.2f}"),
            ("ÊÄªÁ≥ªÁªüËÆ∞ÂΩï", f"{total_system:.2f}"),
            ("ÊÄªÂ∫ìÂ≠òÁõòÁÇπ", f"{total_inventory:.2f}"),
            ("ÊÄªÂ∑ÆÂºÇ", f"{total_variance:.2f}"),
            ("ÊÄªÂ∑ÆÂºÇÁéá", f"{overall_variance_percent:.1f}%")
        ]

        for i, (label, value) in enumerate(summary_data):
            row = current_row + (i // 2)
            col = 1 + (i % 2) * 3

            cell_label = ws.cell(row=row, column=col, value=label)
            cell_value = ws.cell(row=row, column=col+1, value=value)
            cell_label.font = Font(bold=True)

            # Color code summary metrics
            if i >= 5:  # Usage metrics
                fill_color = "E8F5E8"
                # Overall variance (now index 10)
                if i == 10 and abs(overall_variance_percent) > 5:
                    fill_color = "FFE6E6" if overall_variance_percent > 0 else "FFF0E6"
                cell_label.fill = PatternFill(
                    start_color=fill_color, end_color=fill_color, fill_type="solid")
                cell_value.fill = PatternFill(
                    start_color=fill_color, end_color=fill_color, fill_type="solid")

        current_row += 3
        return current_row + 1

    def get_dish_material_data(self, data_provider):
        """Query database for comprehensive dish-material relationship data"""
        try:
            with data_provider.db_manager.get_connection() as conn:
                cursor = conn.cursor()

                # Get target date info for monthly sales join
                target_dt = datetime.strptime(self.target_date, '%Y-%m-%d')
                year, month = target_dt.year, target_dt.month

                # Comprehensive query to get dish-material data with all related information
                # Include both regular dish sales and combo dish sales
                sql = """
                WITH combined_dish_sales AS (
                    -- Regular dish sales
                    SELECT 
                        dish_id, store_id,
                        sale_amount, return_amount, free_meal_amount, gift_amount
                    FROM dish_monthly_sale 
                    WHERE year = %s AND month = %s
                    
                    UNION ALL
                    
                    -- Combo dish sales (no return/free/gift amounts for combos)
                    SELECT 
                        dish_id, store_id,
                        sale_amount, 0 as return_amount, 0 as free_meal_amount, 0 as gift_amount
                    FROM monthly_combo_dish_sale 
                    WHERE year = %s AND month = %s
                ),
                aggregated_sales AS (
                    SELECT 
                        dish_id, store_id,
                        SUM(sale_amount) as total_sale_amount,
                        SUM(return_amount) as total_return_amount,
                        SUM(free_meal_amount) as total_free_meal_amount,
                        SUM(gift_amount) as total_gift_amount
                    FROM combined_dish_sales
                    GROUP BY dish_id, store_id
                )
                SELECT 
                    dt.name as dish_type_name,
                    dct.name as dish_child_type_name,
                    d.id as dish_id,
                    d.name as dish_name,
                    d.system_name as dish_system_name,
                    d.full_code as dish_code,
                    d.short_code as dish_short_code,
                    d.size as dish_size,
                    d.unit as dish_unit,
                    d.serving_size_kg,
                    m.id as material_id,
                    m.name as material_name,
                    m.material_number,
                    m.unit as material_unit,
                    m.package_spec,
                    dm.standard_quantity,
                    dm.unit_conversion_rate,
                    -- Get current price for first store (if available)
                    dph.price as current_price,
                    dph.currency,
                    dph.effective_date as price_date,
                    -- Monthly sales data (aggregated from both regular and combo sales)
                    COALESCE(ads.total_sale_amount, 0) as sale_amount,
                    COALESCE(ads.total_return_amount, 0) as return_amount,
                    COALESCE(ads.total_free_meal_amount, 0) as free_meal_amount,
                    COALESCE(ads.total_gift_amount, 0) as gift_amount,
                    -- Material usage data
                    COALESCE(mmu.material_used, 0) as material_used,
                    -- Count total dish-material relationships for this dish
                    COUNT(*) OVER (PARTITION BY d.id) as material_count_for_dish
                FROM dish d
                JOIN dish_child_type dct ON d.dish_child_type_id = dct.id
                JOIN dish_type dt ON dct.dish_type_id = dt.id
                LEFT JOIN dish_material dm ON d.id = dm.dish_id AND d.store_id = dm.store_id
                LEFT JOIN material m ON dm.material_id = m.id AND dm.store_id = m.store_id
                LEFT JOIN dish_price_history dph ON d.id = dph.dish_id AND d.store_id = dph.store_id
                    AND dph.is_active = TRUE 
                LEFT JOIN aggregated_sales ads ON d.id = ads.dish_id AND d.store_id = ads.store_id
                LEFT JOIN material_monthly_usage mmu ON m.id = mmu.material_id AND m.store_id = mmu.store_id
                    AND mmu.year = %s AND mmu.month = %s
                    AND mmu.store_id = ads.store_id  -- Match store for material usage
                WHERE d.is_active = TRUE
                ORDER BY ads.store_id, dt.name, dct.name, d.name, m.name
                """

                cursor.execute(sql, (year, month, year, month, year, month))
                return cursor.fetchall()

        except Exception as e:
            print(f"‚ùå Error fetching dish-material data: {e}")
            return []

    def add_summary_section(self, ws, start_row, dish_data):
        """Add summary statistics section"""
        current_row = start_row

        # Calculate summary statistics
        total_dishes = len(set(row['dish_id'] for row in dish_data))
        total_materials = len(set(row['material_id']
                              for row in dish_data if row['material_id']))
        total_relationships = len(
            [row for row in dish_data if row['material_id']])
        total_dish_types = len(set(row['dish_type_name'] for row in dish_data))

        # Dishes with/without materials
        dishes_with_materials = len(
            set(row['dish_id'] for row in dish_data if row['material_id']))
        dishes_without_materials = total_dishes - dishes_with_materials

        # Monthly performance totals
        total_sales = sum(row['sale_amount'] or 0 for row in dish_data)
        total_returns = sum(row['return_amount'] or 0 for row in dish_data)
        total_free_meals = sum(
            row['free_meal_amount'] or 0 for row in dish_data)
        total_gifts = sum(row['gift_amount'] or 0 for row in dish_data)

        # Create summary section
        ws.merge_cells(f'A{current_row}:D{current_row}')
        ws[f'A{current_row}'] = "Êï∞ÊçÆÁªüËÆ°Ê¶ÇËßà"
        ws[f'A{current_row}'].font = Font(bold=True, size=12)
        ws[f'A{current_row}'].fill = PatternFill(
            start_color="E6F3FF", end_color="E6F3FF", fill_type="solid")
        current_row += 1

        summary_data = [
            ("ËèúÂìÅÊÄªÊï∞", total_dishes),
            ("Áâ©ÊñôÊÄªÊï∞", total_materials),
            ("ÈÖçÊñπÂÖ≥Á≥ªÊÄªÊï∞", total_relationships),
            ("ËèúÂìÅÂ§ßÁ±ªÊï∞", total_dish_types),
            ("ÊúâÈÖçÊñπËèúÂìÅ", dishes_with_materials),
            ("Êó†ÈÖçÊñπËèúÂìÅ", dishes_without_materials),
            ("ÊÄªÈîÄÈáè", f"{total_sales:.0f}"),
            ("ÊÄªÈÄÄËèú", f"{total_returns:.0f}"),
            ("ÊÄªÂÖçË¥πÈ§ê", f"{total_free_meals:.0f}"),
            ("ÊÄªËµ†ÈÄÅ", f"{total_gifts:.0f}")
        ]

        for i, (label, value) in enumerate(summary_data):
            row = current_row + (i // 2)
            col = 1 if i % 2 == 0 else 3

            ws.cell(row=row, column=col, value=label).font = Font(bold=True)
            ws.cell(row=row, column=col+1, value=value)

            # Highlight performance metrics in a different color
            if i >= 6:  # Performance metrics start from index 6
                ws.cell(row=row, column=col).fill = PatternFill(
                    start_color="E8F5E8", end_color="E8F5E8", fill_type="solid")
                ws.cell(row=row, column=col+1).fill = PatternFill(
                    start_color="E8F5E8", end_color="E8F5E8", fill_type="solid")

        current_row += 3
        return current_row + 1

    def add_dish_data_section(self, ws, start_row, dish_data):
        """Add main dish data section"""
        current_row = start_row

        # Headers - Updated to include monthly performance data
        headers = [
            "Â∫èÂè∑", "ËèúÂìÅÂ§ßÁ±ª", "ËèúÂìÅÂ≠êÁ±ª", "ËèúÂìÅÁºñÁ†Å", "ËèúÂìÅÁü≠ÁºñÁ†Å", "ËèúÂìÅÂêçÁß∞",
            "Á≥ªÁªüÂêçÁß∞", "ËßÑÊ†º", "Âçï‰Ωç", "Âá∫ÂìÅÂàÜÈáè(kg)", "Áâ©ÊñôÂè∑", "Áâ©ÊñôÂêçÁß∞",
            "ÂåÖË£ÖËßÑÊ†º", "Ê†áÂáÜÁî®Èáè", "Áâ©ÊñôÂçï‰Ωç", "ÂΩìÂâçÂîÆ‰ª∑", "Ë¥ßÂ∏Å", "‰ª∑Ê†ºÊó•Êúü",
            "ÊúàÈîÄÈáè", "ÈÄÄËèúÈáè", "ÂÖçË¥πÈ§ê", "Ëµ†ÈÄÅÈáè", "Áâ©ÊñôÊ∂àËÄó",
            "ÈÖçÊñπÊï∞Èáè", "Â§áÊ≥®"
        ]

        for col, header in enumerate(headers, 1):
            cell = ws.cell(row=current_row, column=col, value=header)
            cell.font = Font(bold=True, size=10, color="FFFFFF")
            cell.fill = PatternFill(
                start_color="4472C4", end_color="4472C4", fill_type="solid")
            cell.alignment = Alignment(horizontal='center', vertical='center')
        current_row += 1

        # Group data by dish to handle dishes with multiple materials
        dishes_processed = set()
        row_number = 1

        for row_data in dish_data:
            dish_id = row_data['dish_id']

            # For dishes with materials, show each material relationship
            if row_data['material_id']:
                self.add_dish_row(ws, current_row, row_number,
                                  row_data, has_material=True)
                row_number += 1
                current_row += 1
            # For dishes without materials, show once (if not already shown)
            elif dish_id not in dishes_processed:
                self.add_dish_row(ws, current_row, row_number,
                                  row_data, has_material=False)
                dishes_processed.add(dish_id)
                row_number += 1
                current_row += 1

            dishes_processed.add(dish_id)

        return current_row

    def add_dish_row(self, ws, row, row_number, data, has_material=True):
        """Add a single dish data row"""

        # Determine remarks based on material availability
        if has_material:
            total_materials = data['material_count_for_dish'] if data['material_count_for_dish'] else 0
            remarks = f"ÂÖ±{total_materials}ÁßçÁâ©Êñô" if total_materials > 1 else "Âçï‰∏ÄÁâ©Êñô"
        else:
            remarks = "ÊöÇÊó†ÈÖçÊñπ"

        row_data = [
            row_number,  # Â∫èÂè∑
            data['dish_type_name'],  # ËèúÂìÅÂ§ßÁ±ª
            data['dish_child_type_name'],  # ËèúÂìÅÂ≠êÁ±ª
            data['dish_code'],  # ËèúÂìÅÁºñÁ†Å
            data['dish_short_code'] or '',  # ËèúÂìÅÁü≠ÁºñÁ†Å
            data['dish_name'],  # ËèúÂìÅÂêçÁß∞
            data['dish_system_name'] or data['dish_name'],  # Á≥ªÁªüÂêçÁß∞
            data['dish_size'] or '',  # ËßÑÊ†º
            data['dish_unit'] or '‰ªΩ',  # Âçï‰Ωç
            data['serving_size_kg'] or 0.0,  # Âá∫ÂìÅÂàÜÈáè(kg)
            data['material_number'] or '',  # Áâ©ÊñôÂè∑
            data['material_name'] or '',  # Áâ©ÊñôÂêçÁß∞
            data['package_spec'] or '',  # ÂåÖË£ÖËßÑÊ†º
            data['standard_quantity'] or '',  # Ê†áÂáÜÁî®Èáè
            data['material_unit'] or '',  # Áâ©ÊñôÂçï‰Ωç
            data['current_price'] or '',  # ÂΩìÂâçÂîÆ‰ª∑
            data['currency'] or '',  # Ë¥ßÂ∏Å
            data['price_date'].strftime(
                '%Y-%m-%d') if data['price_date'] else '',  # ‰ª∑Ê†ºÊó•Êúü
            # Monthly performance data
            data['sale_amount'] or 0,  # ÊúàÈîÄÈáè
            data['return_amount'] or 0,  # ÈÄÄËèúÈáè
            data['free_meal_amount'] or 0,  # ÂÖçË¥πÈ§ê
            data['gift_amount'] or 0,  # Ëµ†ÈÄÅÈáè
            data['material_used'] or 0,  # Áâ©ÊñôÊ∂àËÄó
            data['material_count_for_dish'] or 0,  # ÈÖçÊñπÊï∞Èáè
            remarks  # Â§áÊ≥®
        ]

        for col, value in enumerate(row_data, 1):
            cell = ws.cell(row=row, column=col, value=value)

            # Highlight dishes without materials
            if not has_material:
                cell.fill = PatternFill(
                    start_color="FFF2CC", end_color="FFF2CC", fill_type="solid")

            # Format numeric columns
            # Serving size, standard quantity, price, monthly performance data
            if col in [10, 14, 16, 19, 20, 21, 22, 23, 24]:
                if isinstance(value, (int, float)) and value != 0:
                    if col == 16:  # Price
                        cell.number_format = '#,##0.00'
                    # Sales performance data (whole numbers)
                    elif col in [19, 20, 21, 22, 23]:
                        cell.number_format = '#,##0'
                    else:  # Material quantities (decimal)
                        cell.number_format = '#,##0.0000'

            # Center align certain columns
            # Serial, short code, size, unit, material unit, currency, count, performance metrics
            if col in [1, 4, 8, 9, 15, 17, 19, 20, 21, 22, 23, 24, 25]:
                cell.alignment = Alignment(horizontal='center')

    def apply_common_formatting(self, ws, max_row):
        """Apply common formatting to the worksheet"""

        # Add borders to data section
        thin_border = Border(
            left=Side(style='thin'),
            right=Side(style='thin'),
            top=Side(style='thin'),
            bottom=Side(style='thin')
        )

        # Find where data section starts (after summary)
        data_start_row = 1
        for row in range(1, max_row + 1):
            if ws.cell(row=row, column=1).value == "Â∫èÂè∑":
                data_start_row = row
                break

        # Apply borders to data section
        for row in range(data_start_row, max_row + 1):
            for col in range(1, 26):  # Updated to 25 columns (removed 2 stock columns)
                cell = ws.cell(row=row, column=col)
                cell.border = thin_border

                # Wrap text for long content columns
                if col in [6, 7, 12, 13, 25]:  # Name columns and remarks
                    cell.alignment = Alignment(wrap_text=True, vertical='top')

        # Freeze panes at data header
        if data_start_row > 1:
            ws.freeze_panes = f'A{data_start_row + 1}'

        # Auto-fit row heights for wrapped text
        for row in range(data_start_row, max_row + 1):
            ws.row_dimensions[row].height = None  # Auto height

    def check_unit_conversion_rate_column_exists(self, db_manager):
        """Check if unit_conversion_rate column exists in dish_material table"""
        try:
            with db_manager.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("""
                    SELECT column_name 
                    FROM information_schema.columns 
                    WHERE table_name = 'dish_material' 
                    AND column_name = 'unit_conversion_rate'
                """)
                result = cursor.fetchone()
                return result is not None
        except Exception as e:
            print(f"Error checking unit_conversion_rate column: {e}")
            return False

    def get_dish_usage_details(self, data_provider, material_id: int, store_id: int, year: int, month: int):
        """Get detailed dish usage information for a specific material and store"""
        try:
            with data_provider.db_manager.get_connection() as conn:
                cursor = conn.cursor()
                
                # Check if unit_conversion_rate column exists
                has_conversion_rate = self.check_unit_conversion_rate_column_exists(data_provider.db_manager)
                
                # Get detailed dish sales and material usage information
                if has_conversion_rate:
                    calculation_sql = """
                        dm.standard_quantity * COALESCE(dm.loss_rate, 1.0) * COALESCE(dm.unit_conversion_rate, 1.0) as material_per_dish
                    """
                else:
                    calculation_sql = """
                        dm.standard_quantity * COALESCE(dm.loss_rate, 1.0) as material_per_dish
                    """
                
                cursor.execute(f"""
                    WITH aggregated_dish_sales AS (
                        SELECT 
                            dish_id,
                            store_id,
                            SUM(COALESCE(sale_amount, 0)) as total_sale_amount,
                            SUM(COALESCE(return_amount, 0)) as total_return_amount
                        FROM dish_monthly_sale
                        WHERE year = %s AND month = %s AND store_id = %s
                        GROUP BY dish_id, store_id
                    ),
                    dish_net_sales AS (
                        SELECT 
                            dish_id,
                            store_id,
                            (total_sale_amount - total_return_amount) as net_sales
                        FROM aggregated_dish_sales
                    )
                    SELECT 
                        d.name as dish_name,
                        d.specification as dish_spec,
                        dns.net_sales,
                        COALESCE(dm.standard_quantity, 0) as material_quantity,
                        COALESCE(dm.loss_rate, 1.0) as loss_rate,
                        COALESCE(dm.unit_conversion_rate, 1.0) as unit_conversion_rate,
                        {calculation_sql},
                        m.unit as material_unit,
                        (dns.net_sales * {calculation_sql.replace('as material_per_dish', '')}) as total_material_used
                    FROM dish_net_sales dns
                    INNER JOIN dish d ON dns.dish_id = d.id AND d.store_id = dns.store_id
                    INNER JOIN dish_material dm ON d.id = dm.dish_id AND d.store_id = dm.store_id
                    INNER JOIN material m ON dm.material_id = m.id AND dm.store_id = m.store_id
                    WHERE dm.material_id = %s AND m.store_id = %s
                        AND dns.net_sales > 0
                        AND dns.store_id = %s
                    ORDER BY dns.net_sales DESC
                """, (year, month, store_id, material_id, store_id, store_id))
                
                regular_usage_details = cursor.fetchall()
                
                # Get combo usage from monthly_combo_dish_sale table (same as in variance calculation)
                if has_conversion_rate:
                    combo_calculation_sql = "SUM(cds.net_sales * COALESCE(dm.standard_quantity, 0) * COALESCE(dm.loss_rate, 1.0) * COALESCE(dm.unit_conversion_rate, 1.0))"
                else:
                    combo_calculation_sql = "SUM(cds.net_sales * COALESCE(dm.standard_quantity, 0) * COALESCE(dm.loss_rate, 1.0))"
                
                cursor.execute(f"""
                    WITH combo_dish_sales AS (
                        SELECT 
                            d.id as dish_id,
                            d.name as dish_name,
                            mcds.store_id,
                            COALESCE(mcds.sale_amount, 0) as net_sales
                        FROM dish d
                        LEFT JOIN monthly_combo_dish_sale mcds ON d.id = mcds.dish_id AND d.store_id = mcds.store_id
                            AND mcds.year = %s AND mcds.month = %s AND mcds.store_id = %s
                        WHERE d.is_active = TRUE AND mcds.store_id IS NOT NULL
                    )
                    SELECT 
                        COALESCE({combo_calculation_sql}, 0) as combo_usage
                    FROM material m
                    LEFT JOIN dish_material dm ON m.id = dm.material_id AND m.store_id = dm.store_id
                    LEFT JOIN combo_dish_sales cds ON dm.dish_id = cds.dish_id AND dm.store_id = cds.store_id
                    WHERE m.id = %s AND m.store_id = %s
                        AND cds.store_id IS NOT NULL
                """, (year, month, store_id, material_id, store_id))
                
                combo_result = cursor.fetchone()
                combo_usage = combo_result['combo_usage'] if combo_result and combo_result['combo_usage'] else 0
                
                # Format the usage details into a comprehensive string
                if not regular_usage_details and combo_usage == 0:
                    return "Êó†‰ΩøÁî®ËÆ∞ÂΩï"
                
                usage_lines = []
                
                # Add regular dish usage details
                for detail in regular_usage_details:
                    dish_name = detail['dish_name'] or 'Êú™Áü•ËèúÂìÅ'
                    dish_spec = detail['dish_spec'] if detail['dish_spec'] else ''
                    net_sales = detail['net_sales']
                    material_quantity = detail['material_quantity']
                    loss_rate = detail['loss_rate']
                    unit_conversion = detail['unit_conversion_rate'] if has_conversion_rate else 1.0
                    material_unit = detail['material_unit'] or ''
                    total_material_used = detail['total_material_used']
                    
                    # Format dish name with specification
                    full_dish_name = f"{dish_name} {dish_spec}".strip()
                    
                    # Create detailed usage line
                    detail_line = (f"{full_dish_name} sale-{net_sales} "
                                 f"Âá∫ÂìÅÂàÜÈáè(kg)-{material_quantity} "
                                 f"ÊçüËÄó-{loss_rate} "
                                 f"Áâ©ÊñôÂçï‰Ωç-{unit_conversion} "
                                 f"materials_use-{total_material_used:.4f}")
                    
                    usage_lines.append(detail_line)
                
                # Add combo usage only if > 0
                if combo_usage > 0:
                    usage_lines.append(f"Â•óÈ§ê - {combo_usage:.4f}")
                
                return '\n'.join(usage_lines)
                
        except Exception as e:
            print(f"Error getting dish usage details for material {material_id}: {e}")
            import traceback
            traceback.print_exc()
            return "Ëé∑ÂèñËØ¶ÊÉÖÂ§±Ë¥•"

    def get_material_variance_data(self, data_provider, year: int, month: int):
        """Calculate material usage variance between theoretical and system record"""
        try:
            # Check if unit_conversion_rate column exists
            has_conversion_rate = self.check_unit_conversion_rate_column_exists(
                data_provider.db_manager)

            if not has_conversion_rate:
                print(
                    "‚ö†Ô∏è  unit_conversion_rate column not found. Using fallback calculation without conversion.")
                print(
                    "üí° To enable unit conversion rates, run: Database Management ‚Üí Option 7 (Migration)")

            with data_provider.db_manager.get_connection() as conn:
                cursor = conn.cursor()

                # Get only materials that have dish_material records with standard_quantity (store-specific)
                cursor.execute("""
                    SELECT DISTINCT m.id as material_id, m.store_id
                    FROM material m
                    WHERE m.is_active = TRUE
                    AND EXISTS (SELECT 1 FROM dish_material dm WHERE dm.material_id = m.id AND dm.store_id = m.store_id)
                """, ())

                all_materials = cursor.fetchall()
                material_store_pairs = [(row['material_id'], row['store_id']) for row in all_materials]

                if not material_store_pairs:
                    print("‚ö†Ô∏è  No materials found with dish-material relationships")
                    return [{
                        'material_id': 0,
                        'store_id': 1,
                        'store_name': 'Á≥ªÁªüËØ¥Êòé',
                        'material_name': 'ÊöÇÊó†ÈÖçÊñπÁâ©ÊñôÊï∞ÊçÆ',
                        'material_number': '',
                        'material_unit': '',
                        'dish_usage_details': 'Êó†‰ΩøÁî®ËÆ∞ÂΩï',
                        'theoretical_usage': 0,
                        'combo_usage': 0,
                        'system_record': 0,
                        'inventory_count': 0,
                        'variance_amount': 0,
                        'variance_percent': 0,
                        'variance_status': 'Ê≠£Â∏∏',
                        'material_price': 0
                    }]

                # Choose SQL based on whether unit_conversion_rate column exists
                if has_conversion_rate:
                    calculation_sql = "SUM(ds.net_sales * COALESCE(dm.standard_quantity, 0) * COALESCE(dm.loss_rate, 1.0) * COALESCE(dm.unit_conversion_rate, 1.0)) as theoretical_total"
                else:
                    calculation_sql = "SUM(ds.net_sales * COALESCE(dm.standard_quantity, 0) * COALESCE(dm.loss_rate, 1.0)) as theoretical_total"

                # Get regular theoretical usage (dish sales * standard_quantity * loss_rate * unit_conversion_rate) - Store-specific
                regular_theoretical_sql = f"""
                WITH aggregated_dish_sales AS (
                    SELECT 
                        dish_id,
                        store_id,
                        SUM(COALESCE(sale_amount, 0)) as total_sale_amount,
                        SUM(COALESCE(return_amount, 0)) as total_return_amount
                    FROM dish_monthly_sale
                    WHERE year = %s AND month = %s
                    GROUP BY dish_id, store_id
                ),
                dish_sales AS (
                    SELECT 
                        d.id as dish_id,
                        d.name as dish_name,
                        d.store_id,
                        ads.store_id as sale_store_id,
                        s.name as store_name,
                        COALESCE(ads.total_sale_amount, 0) - COALESCE(ads.total_return_amount, 0) as net_sales
                    FROM dish d
                    LEFT JOIN aggregated_dish_sales ads ON d.id = ads.dish_id AND d.store_id = ads.store_id
                    LEFT JOIN store s ON ads.store_id = s.id
                    WHERE d.is_active = TRUE AND ads.store_id IS NOT NULL
                ),
                regular_theoretical_usage AS (
                    SELECT 
                        m.id as material_id,
                        m.name as material_name,
                        m.material_number,
                        m.unit as material_unit,
                        ds.sale_store_id as store_id,
                        ds.store_name,
                        {calculation_sql}
                    FROM material m
                    LEFT JOIN dish_material dm ON m.id = dm.material_id AND m.store_id = dm.store_id
                    LEFT JOIN dish_sales ds ON dm.dish_id = ds.dish_id AND dm.store_id = ds.store_id
                    WHERE m.is_active = TRUE AND ds.sale_store_id IS NOT NULL
                        AND (m.id, m.store_id) = ANY(%s)
                    GROUP BY m.id, m.name, m.material_number, m.unit, ds.sale_store_id, ds.store_name
                )
                SELECT * FROM regular_theoretical_usage
                ORDER BY store_name, material_name
                """

                cursor.execute(regular_theoretical_sql,
                               (year, month, material_store_pairs))
                regular_theoretical_data = cursor.fetchall()

                # Choose combo calculation SQL based on whether unit_conversion_rate column exists
                if has_conversion_rate:
                    combo_calculation_sql = "SUM(cds.net_sales * COALESCE(dm.standard_quantity, 0) * COALESCE(dm.loss_rate, 1.0) * COALESCE(dm.unit_conversion_rate, 1.0)) as combo_total"
                else:
                    combo_calculation_sql = "SUM(cds.net_sales * COALESCE(dm.standard_quantity, 0) * COALESCE(dm.loss_rate, 1.0)) as combo_total"

                # Get combo usage (combo dish sales * standard_quantity * loss_rate * unit_conversion_rate) - Store-specific
                combo_usage_sql = f"""
                WITH combo_dish_sales AS (
                    SELECT 
                        d.id as dish_id,
                        d.name as dish_name,
                        d.store_id,
                        mcds.store_id as sale_store_id,
                        s.name as store_name,
                        COALESCE(mcds.sale_amount, 0) as net_sales
                    FROM dish d
                    LEFT JOIN monthly_combo_dish_sale mcds ON d.id = mcds.dish_id AND d.store_id = mcds.store_id
                        AND mcds.year = %s AND mcds.month = %s
                    LEFT JOIN store s ON mcds.store_id = s.id
                    WHERE d.is_active = TRUE AND mcds.store_id IS NOT NULL
                ),
                combo_theoretical_usage AS (
                    SELECT 
                        m.id as material_id,
                        m.name as material_name,
                        m.material_number,
                        m.unit as material_unit,
                        cds.sale_store_id as store_id,
                        cds.store_name,
                        {combo_calculation_sql}
                    FROM material m
                    LEFT JOIN dish_material dm ON m.id = dm.material_id AND m.store_id = dm.store_id
                    LEFT JOIN combo_dish_sales cds ON dm.dish_id = cds.dish_id AND dm.store_id = cds.store_id
                    WHERE m.is_active = TRUE AND cds.sale_store_id IS NOT NULL
                        AND (m.id, m.store_id) = ANY(%s)
                    GROUP BY m.id, m.name, m.material_number, m.unit, cds.sale_store_id, cds.store_name
                )
                SELECT * FROM combo_theoretical_usage
                ORDER BY store_name, material_name
                """

                cursor.execute(combo_usage_sql, (year, month, material_store_pairs))
                combo_usage_data = cursor.fetchall()

                # Get system record (material_monthly_usage.material_used) - Store-specific
                system_sql = """
                SELECT 
                    m.id as material_id,
                    m.name as material_name,
                    m.material_number,
                    m.unit as material_unit,
                    m.package_spec,
                    mmu.store_id,
                    s.name as store_name,
                    COALESCE(mmu.material_used, 0) as system_record
                FROM material m
                LEFT JOIN material_monthly_usage mmu ON m.id = mmu.material_id AND m.store_id = mmu.store_id
                    AND mmu.year = %s AND mmu.month = %s
                LEFT JOIN store s ON mmu.store_id = s.id
                WHERE m.is_active = TRUE AND mmu.store_id IS NOT NULL
                    AND (m.id, m.store_id) = ANY(%s)
                ORDER BY s.name, m.name
                """

                cursor.execute(system_sql, (year, month, material_store_pairs))
                system_data = cursor.fetchall()

                # Get inventory count (inventory_count.counted_quantity) - Store-specific
                inventory_sql = """
                SELECT 
                    m.id as material_id,
                    m.name as material_name,
                    m.material_number,
                    m.unit as material_unit,
                    m.package_spec,
                    ic.store_id,
                    s.name as store_name,
                    COALESCE(ic.counted_quantity, 0) as inventory_count
                FROM material m
                LEFT JOIN inventory_count ic ON m.id = ic.material_id AND m.store_id = ic.store_id
                LEFT JOIN store s ON ic.store_id = s.id
                WHERE m.is_active = TRUE AND ic.store_id IS NOT NULL
                    AND (m.id, m.store_id) = ANY(%s)
                    AND EXTRACT(year FROM ic.count_date) = %s 
                    AND EXTRACT(month FROM ic.count_date) = %s
                ORDER BY s.name, m.id
                """

                cursor.execute(inventory_sql, (material_store_pairs, year, month))
                inventory_data = cursor.fetchall()

                # Get material prices for the target month - Store-specific
                price_sql = """
                SELECT 
                    m.id as material_id,
                    m.name as material_name,
                    mph.store_id,
                    s.name as store_name,
                    COALESCE(mph.price, 0) as material_price
                FROM material m
                LEFT JOIN material_price_history mph ON m.id = mph.material_id AND m.store_id = mph.store_id
                LEFT JOIN store s ON mph.store_id = s.id
                WHERE m.is_active = TRUE 
                    AND mph.is_active = true
                    AND mph.effective_date <= (date_trunc('month', make_date(%s, %s, 1)) + interval '1 month - 1 day')::date
                    AND (m.id, m.store_id) = ANY(%s)
                ORDER BY s.name, m.id, mph.effective_date DESC
                """
                
                cursor.execute(price_sql, (year, month, material_store_pairs))
                price_data = cursor.fetchall()

                # Combine all data
                regular_theoretical_dict = {
                    (row['material_id'], row['store_id']): row for row in regular_theoretical_data}
                combo_usage_dict = {
                    (row['material_id'], row['store_id']): row for row in combo_usage_data}
                system_dict = {
                    (row['material_id'], row['store_id']): row for row in system_data}
                inventory_dict = {
                    (row['material_id'], row['store_id']): row for row in inventory_data}
                
                # Create price dictionary - get latest price for each material-store combination
                price_dict = {}
                for row in price_data:
                    key = (row['material_id'], row['store_id'])
                    if key not in price_dict:  # Take first (latest) price due to ORDER BY
                        price_dict[key] = row

                # Create combined variance data
                variance_data = []

                # Get all unique material-store combinations
                all_combinations = set()
                for row in regular_theoretical_data + combo_usage_data + system_data + inventory_data:
                    all_combinations.add((row['material_id'], row['store_id']))

                for material_id, store_id in all_combinations:
                    regular_theoretical_row = regular_theoretical_dict.get(
                        (material_id, store_id), {})
                    combo_usage_row = combo_usage_dict.get(
                        (material_id, store_id), {})
                    system_row = system_dict.get((material_id, store_id), {})
                    inventory_row = inventory_dict.get(
                        (material_id, store_id), {})
                    price_row = price_dict.get((material_id, store_id), {})

                    # Get material info from any available row
                    info_row = regular_theoretical_row or combo_usage_row or system_row or inventory_row
                    if not info_row:
                        continue

                    # Ensure we have all required fields with defaults
                    material_name = info_row.get(
                        'material_name', f'Material_{material_id}')
                    material_number = info_row.get('material_number', '')
                    material_unit = info_row.get('material_unit', '')
                    store_name = info_row.get(
                        'store_name', f'Store_{store_id}')

                    regular_theoretical_usage = regular_theoretical_row.get(
                        'theoretical_total', 0) or 0
                    combo_usage = combo_usage_row.get('combo_total', 0) or 0
                    theoretical_usage = regular_theoretical_usage + \
                        combo_usage  # Combined for variance calculation
                    system_record = system_row.get('system_record', 0) or 0
                    inventory_count = inventory_row.get(
                        'inventory_count', 0) or 0
                    material_price = price_row.get('material_price', 0) or 0

                    # Calculate variance to match Excel formula: H - (G + I)
                    # This matches the Excel formula: =I{row}-(G{row}+H{row}) (will be updated with new column positions)
                    variance_amount = system_record - \
                        (theoretical_usage + inventory_count)

                    # Calculate variance percentage using system record as denominator
                    # Formula: abs(variance_amount) / system_record * 100
                    if system_record > 0:
                        variance_percent = abs(
                            variance_amount) / system_record * 100
                    elif variance_amount != 0:
                        variance_percent = 100.0
                    else:
                        variance_percent = 0

                    # Determine variance status based on calculated percentage
                    variance_status = "Ê≠£Â∏∏"
                    if abs(variance_percent) > 5:
                        if variance_amount > 0:
                            variance_status = "Ë∂ÖÈáè"
                        else:
                            variance_status = "Â∞ëÁî®"

                    # Get dish usage details for this material and store
                    dish_usage_details = self.get_dish_usage_details(
                        data_provider, material_id, store_id, year, month)

                    variance_data.append({
                        'material_id': material_id,
                        'store_id': store_id,
                        'store_name': store_name,
                        'material_name': material_name,
                        'material_number': material_number,
                        'material_unit': material_unit,
                        'dish_usage_details': dish_usage_details,
                        'theoretical_usage': regular_theoretical_usage,
                        'combo_usage': combo_usage,
                        'system_record': system_record,
                        'inventory_count': inventory_count,
                        'variance_amount': variance_amount,
                        'variance_percent': variance_percent,
                        'variance_status': variance_status,
                        'material_price': material_price
                    })

                return sorted(variance_data, key=lambda x: (x['store_name'], x['material_name']))

        except Exception as e:
            print(f"‚ùå Error calculating material variance data: {e}")
            return []

    def add_variance_summary_section(self, ws, start_row, variance_data):
        """Add variance summary statistics section"""
        current_row = start_row

        # Calculate summary statistics
        total_materials = len(variance_data)
        materials_over_threshold = len(
            [row for row in variance_data if abs(row['variance_percent']) > 5])
        materials_normal = total_materials - materials_over_threshold

        over_usage = len(
            [row for row in variance_data if row['variance_percent'] > 5])
        under_usage = len(
            [row for row in variance_data if row['variance_percent'] < -5])

        total_theoretical = sum(row['theoretical_usage']
                                for row in variance_data)
        total_combo_usage = sum(row['combo_usage']
                                for row in variance_data)
        total_combined_theoretical = total_theoretical + total_combo_usage
        total_system = sum(row['system_record'] for row in variance_data)
        total_inventory = sum(row['inventory_count'] for row in variance_data)
        total_variance = total_system - total_combined_theoretical
        overall_variance_percent = (
            total_variance / total_combined_theoretical * 100) if total_combined_theoretical > 0 else 0

        # Create summary section
        ws.merge_cells(f'A{current_row}:D{current_row}')
        ws[f'A{current_row}'] = "Â∑ÆÂºÇÂàÜÊûêÊ¶ÇËßà"
        ws[f'A{current_row}'].font = Font(bold=True, size=12)
        ws[f'A{current_row}'].fill = PatternFill(
            start_color="E6F3FF", end_color="E6F3FF", fill_type="solid")
        current_row += 1

        summary_data = [
            ("Áâ©ÊñôÊÄªÊï∞", total_materials),
            ("Â∑ÆÂºÇË∂Ö5%Áâ©Êñô", materials_over_threshold),
            ("Ê≠£Â∏∏ËåÉÂõ¥Áâ©Êñô", materials_normal),
            ("Ë∂ÖÈáè‰ΩøÁî®Áâ©Êñô", over_usage),
            ("Â∞ëÁî®Áâ©Êñô", under_usage),
            ("ÊÄªÁêÜËÆ∫Áî®Èáè", f"{total_theoretical:.2f}"),
            ("ÊÄªÂ•óÈ§êÁî®Èáè", f"{total_combo_usage:.2f}"),
            ("ÊÄªÁ≥ªÁªüËÆ∞ÂΩï", f"{total_system:.2f}"),
            ("ÊÄªÂ∫ìÂ≠òÁõòÁÇπ", f"{total_inventory:.2f}"),
            ("ÊÄªÂ∑ÆÂºÇ", f"{total_variance:.2f}"),
            ("ÊÄªÂ∑ÆÂºÇÁéá", f"{overall_variance_percent:.1f}%")
        ]

        for i, (label, value) in enumerate(summary_data):
            row = current_row + (i // 2)
            col = 1 + (i % 2) * 3

            cell_label = ws.cell(row=row, column=col, value=label)
            cell_value = ws.cell(row=row, column=col+1, value=value)
            cell_label.font = Font(bold=True)

            # Color code summary metrics
            if i >= 5:  # Usage metrics
                fill_color = "E8F5E8"
                # Overall variance (now index 10)
                if i == 10 and abs(overall_variance_percent) > 5:
                    fill_color = "FFE6E6" if overall_variance_percent > 0 else "FFF0E6"
                cell_label.fill = PatternFill(
                    start_color=fill_color, end_color=fill_color, fill_type="solid")
                cell_value.fill = PatternFill(
                    start_color=fill_color, end_color=fill_color, fill_type="solid")

        current_row += 3
        return current_row + 1

    def add_variance_data_section(self, ws, start_row, variance_data):
        """Add main variance data section"""
        current_row = start_row

        # Headers (removed ÂåÖË£ÖËßÑÊ†º column, added 2 new cost columns)
        headers = [
            "Â∫èÂè∑", "Èó®Â∫ó", "Áâ©ÊñôÂêçÁß∞", "Áâ©ÊñôÂè∑", "Âçï‰Ωç", "‰ΩøÁî®ËèúÂìÅËØ¶ÊÉÖ",
            "ÁêÜËÆ∫Áî®Èáè", "Â•óÈ§êÁî®Èáè", "Á≥ªÁªüËÆ∞ÂΩï", "Â∫ìÂ≠òÁõòÁÇπ", "ÂáèÂéªÁõòÁÇπÁî®Èáè", "Â∑ÆÂºÇÊï∞Èáè", "Â∑ÆÂºÇÁéá(%)", "Áä∂ÊÄÅ",
            "Êú¨ÊúàÊÄªÊ∂àË¥πÈáëÈ¢ù", "Â∑ÆÂºÇÈáëÈ¢ù"
        ]

        for col, header in enumerate(headers, 1):
            cell = ws.cell(row=current_row, column=col, value=header)
            cell.font = Font(bold=True, size=10, color="FFFFFF")
            cell.fill = PatternFill(
                start_color="4472C4", end_color="4472C4", fill_type="solid")
            cell.alignment = Alignment(horizontal='center', vertical='center')
        current_row += 1

        # Data rows
        for row_number, data in enumerate(variance_data, 1):
            # Basic data (columns A-J, added dish usage details)
            basic_data = [
                row_number,                      # A: Â∫èÂè∑
                data['store_name'],              # B: Èó®Â∫ó
                data['material_name'],           # C: Áâ©ÊñôÂêçÁß∞
                data['material_number'] or '',   # D: Áâ©ÊñôÂè∑
                data['material_unit'] or '',     # E: Âçï‰Ωç
                data['dish_usage_details'],      # F: ‰ΩøÁî®ËèúÂìÅËØ¶ÊÉÖ
                data['theoretical_usage'],       # G: ÁêÜËÆ∫Áî®Èáè (regular only)
                data['combo_usage'],             # H: Â•óÈ§êÁî®Èáè 
                data['system_record'],           # I: Á≥ªÁªüËÆ∞ÂΩï
                data['inventory_count']          # J: Â∫ìÂ≠òÁõòÁÇπ
            ]

            # Insert basic data (A-J)
            for col, value in enumerate(basic_data, 1):
                cell = ws.cell(row=current_row, column=col, value=value)

                # Format numeric columns
                if col in [7, 8, 9, 10]:  # Usage amounts, combo usage, system record, inventory count
                    cell.number_format = '#,##0.0000'

                # Center align certain columns
                if col in [1, 2, 5]:  # Serial, store, unit
                    cell.alignment = Alignment(horizontal='center')
                    
                # Text wrap for dish usage details
                if col == 6:  # ‰ΩøÁî®ËèúÂìÅËØ¶ÊÉÖ
                    cell.alignment = Alignment(wrap_text=True, vertical='top')

            # K: ÂáèÂéªÁõòÁÇπÁî®Èáè (System Record - Inventory Count) - Excel formula: = I - J
            system_minus_inventory_formula = f"=I{current_row}-J{current_row}"
            system_minus_inventory_cell = ws.cell(
                row=current_row, column=11, value=system_minus_inventory_formula)
            system_minus_inventory_cell.number_format = '#,##0.0000'

            # L: Â∑ÆÂºÇÊï∞Èáè (Variance Amount) - Excel formula: = I - (G+H+J)
            variance_formula = f"=I{current_row}-(G{current_row}+H{current_row}+J{current_row})"
            variance_cell = ws.cell(
                row=current_row, column=12, value=variance_formula)
            variance_cell.number_format = '#,##0.0000'

            # M: Â∑ÆÂºÇÁéá (Variance Rate) - Excel formula: = ABS(L/I)*100 with error handling
            # Use system record (I) for percentage calculation
            rate_formula = f"=IF(I{current_row}=0,IF(L{current_row}=0,0,100),ABS(L{current_row}/I{current_row})*100)"
            rate_cell = ws.cell(row=current_row, column=13, value=rate_formula)
            # Fixed percentage format with exactly 2 decimal places
            rate_cell.number_format = '0.00"%"'
            rate_cell.alignment = Alignment(horizontal='center')

            # N: Áä∂ÊÄÅ (Status)
            status_cell = ws.cell(row=current_row, column=14,
                                  value=data['variance_status'])
            status_cell.alignment = Alignment(horizontal='center')

            # O: Êú¨ÊúàÊÄªÊ∂àË¥πÈáëÈ¢ù (Total money spent this month)
            # Formula: (ÁêÜËÆ∫Áî®Èáè + Â•óÈ§êÁî®Èáè + Á≥ªÁªüËÆ∞ÂΩï) √ó Áâ©ÊñôÂçï‰ª∑
            # = (G + H + I) √ó material_price
            total_usage_cost_formula = f"=(G{current_row}+H{current_row}+I{current_row})*{data['material_price']}"
            total_cost_cell = ws.cell(row=current_row, column=15, value=total_usage_cost_formula)
            total_cost_cell.number_format = '#,##0.00'

            # P: Â∑ÆÂºÇÈáëÈ¢ù (Variance cost)
            # Formula: Â∑ÆÂºÇÊï∞Èáè √ó Áâ©ÊñôÂçï‰ª∑ = L √ó material_price
            variance_cost_formula = f"=L{current_row}*{data['material_price']}"
            variance_cost_cell = ws.cell(row=current_row, column=16, value=variance_cost_formula)
            variance_cost_cell.number_format = '#,##0.00'

            # Apply row-level formatting based on variance status
            if data['variance_status'] in ['Ë∂ÖÈáè', 'Â∞ëÁî®']:
                # Red for Ë∂ÖÈáè (excess), Green for Â∞ëÁî® (under-usage)
                fill_color = "FFE6E6" if data['variance_status'] == 'Ë∂ÖÈáè' else "E8F5E8"
                row_fill = PatternFill(
                    start_color=fill_color, end_color=fill_color, fill_type="solid")

                # Apply fill to all cells in this row (now 16 columns)
                for col in range(1, 17):
                    ws.cell(row=current_row, column=col).fill = row_fill

            current_row += 1

        return current_row

    def apply_variance_formatting(self, ws, max_row):
        """Apply formatting to variance worksheet"""
        # Add borders to data section
        thin_border = Border(
            left=Side(style='thin'),
            right=Side(style='thin'),
            top=Side(style='thin'),
            bottom=Side(style='thin')
        )

        # Find data section start
        data_start_row = 1
        for row in range(1, max_row + 1):
            if ws.cell(row=row, column=1).value == "Â∫èÂè∑":
                data_start_row = row
                break

        # Apply borders to data section
        for row in range(data_start_row, max_row + 1):
            # 14 columns for variance data (removed ÂåÖË£ÖËßÑÊ†º, added 2 cost columns)
            for col in range(1, 15):
                cell = ws.cell(row=row, column=col)
                cell.border = thin_border

        # Freeze panes at data header
        if data_start_row > 1:
            ws.freeze_panes = f'A{data_start_row + 1}'
